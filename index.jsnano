import { connectToWhatsApp } from './core/socket.js';
import { config } from './config.js';
import fs from 'fs';
import { getContentType } from '@whiskeysockets/baileys';

async function start() {
    const sock = await connectToWhatsApp();
    console.log(`âš”ï¸ ${config.botName} IS STARTING...`);

    const commands = new Map();
    const pluginFiles = fs.readdirSync('./plugins').filter(file => file.endsWith('.js'));

    for (const file of pluginFiles) {
        const { command } = await import(`./plugins/${file}`);
        commands.set(command.name, command);
        if (command.alias) {
            command.alias.forEach(alias => commands.set(alias, command));
        }
    }

    sock.ev.on('messages.upsert', async (m) => {
        const msg = m.messages[0];
        if (!msg.message || msg.key.remoteJid === 'status@broadcast') return;

        const from = msg.key.remoteJid;
        const type = getContentType(msg.message);
        const text = (type === 'conversation') ? msg.message.conversation : 
                     (type === 'extendedTextMessage') ? msg.message.extendedTextMessage.text : 
                     (type === 'imageMessage') ? msg.message.imageMessage.caption : 
                     (type === 'videoMessage') ? msg.message.videoMessage.caption : '';

        // ğŸ›¡ï¸ 1. Ù†Ø¸Ø§Ù… Ù…Ù†Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
        if (from.endsWith('@g.us') && text.includes('chat.whatsapp.com/')) {
            const groupMetadata = await sock.groupMetadata(from);
            const sender = msg.key.participant;
            const botId = sock.user.id.split(':')[0] + '@s.whatsapp.net';
            const botIsAdmin = groupMetadata.participants.find(p => p.id === botId)?.admin;
            const isSenderAdmin = groupMetadata.participants.find(p => p.id === sender)?.admin;

            if (botIsAdmin && !isSenderAdmin) {
                await sock.sendMessage(from, { delete: msg.key });
                await sock.groupParticipantsUpdate(from, [sender], 'remove');
                return; 
            }
        }

        // ğŸ® 2. Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ (Ø¨Ø¯ÙˆÙ† Ù†Ù‚Ø·Ø©)
        if (sock.fkk && sock.fkk[from]) {
            const targetWord = sock.fkk[from].split('').join(' '); 
            if (text === targetWord) {
                await sock.sendMessage(from, { text: `âœ… ÙƒÙÙˆ ÙŠØ§ Ø¨Ø·Ù„! ÙÙƒÙƒØªÙ‡Ø§ ØµØ­: *${sock.fkk[from]}*` });
                delete sock.fkk[from];
                return;
            }
        }
        if (sock.hazoora && sock.hazoora[from]) {
            if (text.toLowerCase() === sock.hazoora[from].toLowerCase()) {
                await sock.sendMessage(from, { text: `âœ¨ Ø°ÙƒÙŠ! Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©: *${sock.hazoora[from]}*` });
                delete sock.hazoora[from];
                return;
            }
        }

        // âš™ï¸ 3. ÙØ­Øµ Ø§Ù„Ø¨Ø±ÙŠÙÙƒØ³ (Ø§Ù„Ù†Ù‚Ø·Ø©) Ù„Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
        if (!text.startsWith(config.prefix)) return;

        const args = text.slice(config.prefix.length).trim().split(/ +/);
        const commandName = args.shift().toLowerCase();
        const command = commands.get(commandName);

        if (command) {
            try {
                await command.execute(sock, from, msg, args);
            } catch (error) {
                console.error(error);
            }
        }
    });
}

start();

